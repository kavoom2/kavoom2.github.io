I"<&<p>자바스크립트에서 객체기반 프로그래밍은 클래스와 인스턴스로 구현하고 있다. 클래스 용법을 배우기에 앞서 레거시 코드로 구현하면서 원리를 이해하자.</p>

<h2 id="1-인스턴트-생성-패턴instantiation-patterns">1. 인스턴트 생성 패턴(Instantiation Patterns)</h2>
<p>자바스크립트의 객체를 Pseudoclassical 방식이라고 한다. pseudo는 “가짜”라는 뜻을 지니고 있다. 직역하면 가짜로 Class 개념을 구현한다는 뜻이다. 자바스크립트에서는 어떤 편법(?)으로 클래스를 구현했는지 한 번 살펴보자.</p>

<h3 id="1-1-functional">1. 1. Functional</h3>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">Instance</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nx">Instance</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="nx">Instance</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
    <span class="nx">Instance</span><span class="p">.</span><span class="nx">printAll</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`이름은 </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">, 나이는 </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">}</span><span class="s2">살입니다`</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">Instance</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">james</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">james</span><span class="dl">"</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">peter</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">peter</span><span class="dl">"</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="nx">james</span><span class="p">.</span><span class="nx">printAll</span><span class="p">()</span> <span class="c1">// 이름은 james, 나이는 20살입니다</span>
<span class="nx">peter</span><span class="p">.</span><span class="nx">printAll</span><span class="p">()</span> <span class="c1">// 이름은 peter, 나이는 35살입니다</span>
</code></pre></div></div>
<p>이 방식은 james와 peter의 메소드가 별개로 존재한다. 즉, 인스턴스 갯수가 많아질 수록 동일한 구동을 하는 함수가 메모리에서 차지하는 공간이 많아지게 되는 것. 이러한 문제를 다음에 나올 Functional Shared 방식으로 해결할 수 있다.</p>

<h3 id="1-2-functional-shared">1. 2. Functional Shared</h3>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">extend</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="k">from</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">to</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="k">from</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">personMethods</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">personMethods</span><span class="p">.</span><span class="nx">printAll</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`이름은 </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">, 나이는 </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">}</span><span class="s2">살입니다`</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">personMethods</span><span class="p">.</span><span class="nx">changeName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">Instance</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nx">Instance</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="nx">Instance</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
    
    <span class="nx">extend</span><span class="p">(</span><span class="nx">Instance</span><span class="p">,</span> <span class="nx">personMethods</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">Instance</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">james</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">james</span><span class="dl">"</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">peter</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">peter</span><span class="dl">"</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="nx">james</span><span class="p">.</span><span class="nx">printAll</span><span class="p">()</span> <span class="c1">// 이름은 james, 나이는 20살입니다</span>
<span class="nx">peter</span><span class="p">.</span><span class="nx">printAll</span><span class="p">()</span> <span class="c1">// 이름은 peter, 나이는 35살입니다</span>
<span class="nx">james</span><span class="p">.</span><span class="nx">printAll</span> <span class="o">===</span> <span class="nx">peter</span><span class="p">.</span><span class="nx">printAll</span> <span class="c1">// true</span>
</code></pre></div></div>
<p>객체의 메소드의 값을 주소값으로 전달하면 서로 다른 인스턴스도 같은 메소드를 공유하도록 할 수 있다. 인스턴스 james와 peter는 parentMethods에서 메소드를 공유하기 때문에 보다 적은 메모리를 사용한다.</p>

<p>// legacy code (원리를 알 수 있다)
Student = function(name) {
    Human.call(this, name); // 부모 객체까지 this가 전달되지 않으므로, 바인딩해야 한다.
}
Student.prototype = Object.Create(Human.prototype)
Student.prototype.constructor = Student;
Student.prototype.learn = function() {}</p>

<p>// OOP Class
class Human {
    constructor(name) {
        this.name = name;
    }
    sleep() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>} } }
</code></pre></div></div>

<p>class Student extends Human {
    constructor(name) {]
        super(name); // super는 상위객체로 this를 바인딩시켜준다
    }
    learn() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>} }
</code></pre></div></div>

<p>다형성: 자식 객체가 부모 객체와 동일한 메서드를 가지더라도 기능을 변형시키는 것. (유닛은 움직이지만 공중유닛은 지형경계를 무시한다. 지상유닛은 충돌크기를 가지고 있다)</p>

<p>Student.prototype.sleep = function() {
    Human.prototype.sleep.apply(this)
    additional functions…
}</p>

<p>Class Human {
    constructor(name) {
        this.name = name;
    }
    sleep() {
    }
}</p>

<p>Class Student extends Human {
    sleep() {
        super.sleep
        additional functions…
    }
}</p>
:ET