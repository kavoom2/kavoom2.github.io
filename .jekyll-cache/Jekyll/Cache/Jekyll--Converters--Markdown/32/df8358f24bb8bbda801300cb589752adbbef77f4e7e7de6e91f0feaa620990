I"	<p>스타크래프트라는 게임을 해봤을 것이다. 이 게임에는 유닛, 건물, 지형지물 등 수많은 오브젝트가 있는데, 그 중 마린을 하나 만든다고 하자. 마린을 변수로 만들고 위치, 공격, 이동 등 여러 속성과 기능을 구현해야 한다. 수많은 유닛들을 일일이 하드코딩한다고 생각하면 정말 끔찍할 것이다.</p>

<p>이러한 문제를 해결할 수 있는 접근법 중 하나가 객체지향 프로그래밍이다. 객체지향 프로그래밍은 실세계에서 사물이라는 개념을 스크립트 상으로 구현한 것이다. 프로그래밍 언어로 구현한 객체는 핵심이 되는 특징과 기능을 갖도록 설계한다.</p>

<h2 id="2-객체-지향-프로그래밍의-특징">2. 객체 지향 프로그래밍의 특징</h2>
<h3 id="2-1-캡슐화encapsulation">2. 1. 캡슐화(Encapsulation)</h3>

<h3 id="2-2-추상화abstraction">2. 2. 추상화(Abstraction)</h3>

<h3 id="2-3-상속inheritance">2. 3. 상속(Inheritance)</h3>
<p>자식 클래스는 부모 클래스가 가진 특성과 기능을 물려받을 수 있다. 이러한 개념을 상속이라고 한다. 다음 예제를 살펴보자.</p>

<center><div class="mermaid">
graph TB
C(["마린"]) --- D["이동"]
E(["질럿"]) --- F["이동"]
G(["레이스"]) --- H["이동"]
</div></center>
<p>모든 유닛은 움직일 수 있다. 이동 기능을 각 유닛 클래스마다 구현하는 작업은 굉장히 번거로울 것이다. 부모 클래스인 유닛을 만들고, 공통적으로 가지고 있는 기능을 유닛 클래스에 구현하면 된다.</p>
<center><div class="mermaid">
graph TB
A(["유닛(부모 클래스)"]) --- B["기능"]
A --- F["자식 클래스"]
F --- C(["마린"])
F --- E(["질럿"])
F --- G(["레이스"])
B --- H["이동"]
B --- I["정지"]
</div></center>
<p>상속으로 비효율적인 코드 중복을 줄이는 것을 확인했다. 유지보수 측면에서도 부모 클래스만 수정하면 되니 훨씬 편리하다.  <br />
<br /></p>

<h3 id="2-4-다형성polymorphism">2. 4. 다형성(Polymorphism)</h3>
<p>위 예제를 보면서 의문이 생길 것이다. 공중유닛인 레이스는 충돌크기가 없고, 지형지물에 영향을 받지 않는다. 반면 지상유닛은 움직일 수 있는 공간에 제약이 있다. 자식 클래스마다 같은 이동기능이라도 세부적인 기능이 다르다. 이 상황은 어떻게 해결할 수 있을까</p>

:ET