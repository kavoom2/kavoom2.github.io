I"c$<p>다음 글은 <strong>테트리스 예제(https://ui.toast.com/weekly-pick/ko_20191216)</strong>를 직접 구현해보고 정리한 내용이다.  <br />
프로젝트 트리 구성요소들이 어떤 역할을 하는지 정리한다. 그리고, 직접 구현하면서 알아둘 필요가 있는 내용도 덧붙인다.</p>

<h2 id="1-테트로미노의-요소">1. 테트로미노의 요소</h2>
<p>테트리스 게임의 핵심은 블록의 움직임과 물리적 충돌을 어떻게 구현할 것인가이다. 게임 시작, 종료, 점수 매기기 등 기능들은 우선 배제하고 블록의 움직임만 생각해보자.</p>

<h3 id="11-블록의-움직임">1.1. 블록의 움직임</h3>
<p>다음은 게임이 시작하여 종료될 때까지 블록 움직임의 알고리즘을 간단히 적어본 것이다.</p>

<center><div class="mermaid">
graph LR
A["게임시작"] --&gt; B["새로운 블록 생성"]
B --&gt; C{"블록이<br />한 칸 아래로<br />이동가능한가?"}
C --&gt; |"아니오"| D{"종료조건을<br />만족하는가?"}
C --&gt; |"예"| F["블록을 한 칸<br />아래로 이동"]
F --&gt; C
D --&gt; |"아니오"| B
D --&gt; |"예"| E["게임종료"]
</div></center>

<p>블록은 게임이 시작된 직후, 처음 생성된다. 그리고 게임 설정에 따라 일정 시간마다 아래로 한 칸씩 이동한다. 블록이 움직일 수 없는 경우를 고려하여 설계해야 한다.</p>
<blockquote>
  <ol>
    <li>블록이 게임보드 바닥에 도달한 경우</li>
    <li>블록 바로 아래에 다른 블록이 있는 경우</li>
  </ol>
</blockquote>

<p>위 조건을 만족하면 블록은 멈추게 된다. 게임을 계속하려면 새로운 블록을 만들어야 하는데, 그 전에 게임종료 조건에 부합하는지 확인해야 한다. 테트리스에서 주요 종료조건은 “블록이 천장에 닿았는가”이다. 천장에 닿았다면 현재게임을 종료한다. 블록이 천장에 닿지 않는다면, 게임은 새로운 블록이 생성되어 아래로 움직이고, 멈추는 것을 계속 반복한다.</p>

<p>이를 토대로 블록의 움직임을 구현하려면 다음과 같은 기능이 필요하다.</p>
<blockquote>
  <ol>
    <li>새로운 블록 생성</li>
    <li>블록이 다음 위치로 이동이 가능한지 여부 확인</li>
    <li>일정시간마다 블록이 한 칸씩 아래로 이동</li>
  </ol>
</blockquote>

<h3 id="12-블록의-조작">1.2. 블록의 조작</h3>
<p>테트리스 게임에서 블록 조작법은 다음과 같다.</p>
<blockquote>
  <ol>
    <li>블록이동: 왼쪽, 오른쪽, 아래 방향키를 입력하여 원하는 방향으로 이동할 수 있다.</li>
    <li>블록회전: 위쪽 방향키와 Q버튼을 입력하여 블록을 시계방향이나 반시계 방향으로 90도씩 회전할 수 있다.</li>
    <li>하드드롭: 스페이스키를 입력하여 블록을 움직일 수 없는 지점 직전까지 하강시킬 수 있다.</li>
  </ol>
</blockquote>

<p>위 세 기능을 구현하면서 고려해야 할 점이 있다. 앞서, 블록 움직임을 구현하면서 블록이 이동가능한지 확인했었다. 블록을 조작할 때에는 더 고려해야 것이 있다.</p>
<blockquote>
  <ol>
    <li>블록이 게임보드 바닥에 도달한 경우</li>
    <li>블록 바로 아래에 다른 블록이 있는 경우</li>
    <li>블록이 보드 경계지점에 도달한 경우</li>
  </ol>
</blockquote>

<p>방향키 조작이나 회전을 할 경우 블록이 화면 좌측 또는 우측 경계선을 벗어날 수 있다. 따라서, 키 입력을 받고, 블록을 주어진 명령에 따라 이동이나 회전하고 나서 정상적으로 출력되는지 여부도 판단해야 한다. 이를 고려하여 본격적으로 테트리스를 구현하자.</p>

<h2 id="2-게임보드">2. 게임보드</h2>
<p>게임보드와 블록은 클래스(Class)로 규정하였다. 예제에서는 싱글게임이지만 경쟁하는 게임을 구현한다고 생각해보자. 클래스로 원하는 함수와 변수를 담은 객체를 손쉽게 만들어내는게 훨씬 쉽고 직관적이다.</p>

<p>게임보드를 구현하는 함수 board.js의 구성은 크게 다음과 같다.</p>

<center><div class="mermaid">
graph LR
A["class Board"] --- B
A --- C
B["생성자(constructor)"]
B --- Z["변수설정: 캔버스, 블록크기 설정"]
B --- Y["init(), initNext()"]
C["내장함수(function)"]
C --- D["reset()"]
D --- E["getEmptyBoard()"]
C --- F["drop()"]
C --- G["rotate()"]
</div></center>

<h3 id="21-생성자constructor">2.1. 생성자(Constructor)</h3>
<p>생성자(Constructor)는 클래스로 생성한 객체를 초기화하기 위한 메서드이다. 모든 클래스는 하나의 생성자만 가지게 된다. 인스턴스가 생성될 때마다, 생성자 안에 적힌 코드를 실행한다. 속성에 값을 할당하거나, 내장함수를 실행하는 등의 동작이 가능하다. 이 스크립트에서는 게임보드와 블록의 기본크기를 설정하고자 사용했다.</p>

<p>게임보드는 격자판 모양으로 설계한다. 이는 나중에 볼 piece.js에서도 알 수 있지만, 게임보드와 블록을 2차원 행렬로 구현하기 위함이다. 게임보드를 격자가 있는 바둑판이라고 생각해보자. 격자를 이루는 단위 정사각형의 한 변의 길이는 블록 하나의 길이로 설정한다. 이러면 각 블록의 위치를 이차원 행렬로 나타내기 용이하며, 블록을 화면상에 구현하기도 편할 것이다.</p>

<p>constants.js에서 변수 cols, row, blocksize로 미리 값을 설정하였다. 게임보드를 가로가 cols x blocksize, 세로가 rows x blocksize인 사각형으로 설정하자. 그러면, 게임보드는 격자간격이 blocksize인 바둑판이 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// constants.js
const cols = 10;
const rows = 20;
const blocksize = 30;


// board.js
class Board {
    constructor(canvas, canvasNext) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.canvasNext = canvasNext;
        this.ctxNext = canvasNext.getContext("2d");

        this.init();
        this.initNext();
    }
    init() {
        this.canvas.width = cols * blocksize;
        this.canvas.height = rows * blocksize;
        this.ctx.scale(blocksize, blocksize);
    }
    initNext() {
        this.canvasNext.width = cols * blocksize;
        this.canvasNext.height = rows * blocksize;
        this.ctxNext.scale(blocksize, blocksize);
    }
}
</code></pre></div></div>

<p>생성자의 매개인자인 canvas, canvasNext는 main.js에서 querySelector로 캔버스 엘리먼트(<code class="language-plaintext highlighter-rouge">&lt;canvas&gt;...&lt;/canvas&gt;</code>)를 입력받는다. 여기서 canvas는 게임을 진행할 게임보드이고, canvasNext는 다음 블록을 표시하는 보드이다.</p>

<p>캔버스 상에서 그림 그리기는 캔버스 API의 일부인 CanvasRenderingContext2D에서 일어난다. 실질적으로 필요한 것이 이 2D 렌더링 컨텍스트다. ctx에 getContext(“2d”)로 해당 컨텍스트를 할당한다.</p>

<h3 id="22-클래스-내장함수">2.2. 클래스 내장함수</h3>
<p>board.js 내장함수는 크게 보드초기화, 블록하강, 블록회전 함수가 있다. 각 함수의 역할과 구성을 보다 상세히 설명하고자 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// main.js
let board = new Board(canvas, canvasNext);

function play() {
    resetGame();
}

function resetGame() {
    board.reset();
}


// board.js
class Board {
    reset() {
        this.grid = this.getEmptyBoard();
    }
    getEmptyBoard() {
        return Array.from({length: rows}, (y) =&gt; Array(cols).fill(0));
    }
}
</code></pre></div></div>
<p>초기화 함수 reset()은 새로운 게임이 시작될 때마다 실행된다. 이 함수가 실행하는 getEmptyBoard()는 새로운 게임보드를 반환한다. 여기서 게임보드가 어떻게 구성되는지 살펴보자.</p>

<p><img src="https://drive.google.com/uc?export=view&amp;id=1Ws4cKuoJNK09jItFT4LKahXMldkI6be9" alt="screenshot01" /></p>

<p>Array.from()은 유사배열 객체나 순회가능한 객체를 매개인자로 받아 얕은복사를 한 새로운 배열을 만든다. 두 번째 인자로는 배열의 모든 요소에 매핑할 함수를 넣는다. 가령, x =&gt; { 2 * x } 를 넣는다면, 기존배열의 요소들에 각각 2를 곱한 값을 요소로 하는 새로운 새로운 배열을 복사한다.</p>

<p>유사배열 객체는 속성이 length이고, 값이 정수인 객체이다. Array.from({length: rows})을 실행하면, 배열의 길이가 rows이고 요소들은 모두 undefined인 배열이 생성된다. Array(cols)는 길이가 cols이고 요소들은 모두 undefined인 배열을 생성한다.</p>

<p>즉, Array.from({length: rows}, (y) =&gt; Array(cols).fill(0))은 x축 크기가 cols이고 y축 크기가 rows인 2차원 행렬열 만드는 것이다. 이차원행렬을 좌표계로 보고, 어떤 점 위에 블록이 있다면 0 없으면 1로 표기할 수 있다.</p>
:ET