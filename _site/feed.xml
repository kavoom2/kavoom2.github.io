<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://kavoom2.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://kavoom2.github.io/" rel="alternate" type="text/html" /><updated>2021-01-04T21:15:48+09:00</updated><id>https://kavoom2.github.io/feed.xml</id><title type="html">건축공학도의 개발자 성장기</title><subtitle>liondoge's blog</subtitle><author><name>liondoge</name></author><entry><title type="html">Arguments와 Rest parameter</title><link href="https://kavoom2.github.io/javascript101/arguments/" rel="alternate" type="text/html" title="Arguments와 Rest parameter" /><published>2021-01-01T00:00:00+09:00</published><updated>2021-01-05T06:00:00+09:00</updated><id>https://kavoom2.github.io/javascript101/arguments</id><content type="html" xml:base="https://kavoom2.github.io/javascript101/arguments/">&lt;h2 id=&quot;1-arguments&quot;&gt;1. arguments&lt;/h2&gt;
&lt;p&gt;arguments는 함수에 전달한 인자들을 참조하는 객체입니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(a, b, c) {
  console.log(arguments[0]); // 1
  console.log(arguments[1]); // 2
  console.log(arguments[2]); // 3
};
foo(1, 2, 3);;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;arguments은 유사배열입니다. 배열처럼 인덱스는 0에서부터 시작하며, 각 인수를 설정하거나 재할당할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;arguments[0]; // arguments의 0번째 인덱스  &lt;br /&gt;
arguments[1]; // arguments의 1번째 인덱스  &lt;br /&gt;
arguments[2] = ‘new value’; // arguments의 2번째 인덱스 값을 ‘new value’로 설정 또는 재할당&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;arguments 객체는 Array가 아닙니다. 배열에서 사용할 수 있는 pop(), shift() 등 프로퍼티를 가지고 있지 않습니다. 대신, 다음과 같은 방법으로 arguments를 배열로 변환할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;let arg = Array.prototype.slice.call(arguments);  &lt;br /&gt;
let args = Array.from(arguments);  &lt;br /&gt;
let args = […arguments];&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;11-예제&quot;&gt;1.1. 예제&lt;/h2&gt;
&lt;p&gt;arguments 객체는 다음과 같이 전달인자를 변수에 할당하기 힘든 상황에서 유용합니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let memoize = function (func) {
  let cache = {};
  let result;

  return function() {
    let args = Array.prototype.slice.call(arguments);
    if ( args in cache ) {
    return cache[args];
    }
    else {
    cache[args] = func.apply.(null, args);
    };
  };
};

const add = memoize(function(a,b) {
  return a + b;
});

add(2, 3); // 5
add(5, 8); // 13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수 memoize는 어떤 함수에 이전에 전달받은 인자들을 다시 받으면, 즉시 함수 내에 저장한 결과값을 출력합니다. 어떤 인자를 입력했을 때, 그 인자가 한 번 이상 입력받았는지 확인해야 합니다. 즉, 현재 받은 인자가 캐시 안에 있는지 여부를 판단해야 합니다.&lt;/p&gt;

&lt;p&gt;변수 add는 memoize가 반환한 함수 function() {…..}이 할당되어 있습니다. add(2, 3)을 입력하면, arguments 객체는 전달인자 2, 3을 참조합니다.&lt;/p&gt;

&lt;h2 id=&quot;2-rest-parameter&quot;&gt;2. Rest parameter&lt;/h2&gt;
&lt;p&gt;Rest parameter는 정해지지 않은 수의 인자를 배열로 나타냅니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo(a, b, ...args) {
  console.log('a', a);
  console.log('b', b);
  console.log('args', args);
};

foo('one', 'two', 'three', 'four', 'five', 'six');

// a, one
// b, two
// args, [three, four, five, six]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수의 마지막 매개변수에 &lt;strong&gt;…&lt;/strong&gt;을 붙여 모든 나머지 인자들을 배열로 대체합니다. 위 예제는 a, b를 제외한 나머지 인자들을 args 배열로 대체합니다. arguments 객체와 달리 Rest parameter는 실제 배열이며, 배열의 모든 속성에 접근할 수 있습니다. Array의 인스턴스이므로 sort, map, forEach, pop 등 메소드를 바로 적용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 위 예제와 동일한 함수를 사용

foo('one', 'two');
// a, one
// b, two
// args, []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;한편, Rest parameter에 인자를 넣지 않으면 args은 빈배열이 됩니다.&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;
&lt;p&gt;*https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters
*https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments&lt;/p&gt;</content><author><name>liondoge</name></author><category term="Javascript101" /><summary type="html">전달인자 참조 객체의 종류와 활용</summary></entry><entry><title type="html">클로져(Closure)</title><link href="https://kavoom2.github.io/javascript101/closure/" rel="alternate" type="text/html" title="클로져(Closure)" /><published>2021-01-01T00:00:00+09:00</published><updated>2021-01-05T06:05:00+09:00</updated><id>https://kavoom2.github.io/javascript101/closure</id><content type="html" xml:base="https://kavoom2.github.io/javascript101/closure/">&lt;h2 id=&quot;1-클로저closure란&quot;&gt;1. 클로저(Closure)란&lt;/h2&gt;
&lt;p&gt;클로저(closure)는 함수와 그 함수가 선언되었을 때 렉시컬 환경(lexical environment)과의 조합입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스코프(scope)는 함수를 호출할 때가 아니라 &lt;strong&gt;함수를 어디에 선언하였는지에 따라 결정됩니다&lt;/strong&gt;.  &lt;br /&gt;
이러한 개념을 렉시컬 스코핑(Lexical Scoping)라 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function outer() {
  let x = 10;
  let inner = function() {
    console.log(x);
  };
  return inner;
};

outer(); // 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제에서 함수 inner는 자신을 포함하고 있는 외부함수(outer)보다 더 오래 남아있습니다. 이 경우 외부함수 밖에서 내부함수를 호출하더라도 외부함수의 지역변수에 접근할 수 있습니다. 이러한 함수를 클로저(Closure)라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클로저는 반환된 내부함수가 자신이 선언되었을 때의 환경인 스코프를 기억하여, 자신이 선언된 환경 외부에서 호출되어도 그 환경에 접근할 수 있는 함수&lt;/strong&gt;입니다. 즉, 자신이 생성될 때의 환경(Lexical environment)를 기억하는 함수입니다.&lt;/p&gt;

&lt;h2 id=&quot;2-클로저closure의-활용&quot;&gt;2. 클로저(Closure)의 활용&lt;/h2&gt;

&lt;h3 id=&quot;2-1-환경의-기억와-유지&quot;&gt;2. 1. 환경의 기억와 유지&lt;/h3&gt;
&lt;p&gt;클로저는 현재 환경을 기억합니다. 그리고, 환경이 변화할 때마다 가장 최근에 바뀐 상태로 유지합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let funcOnce = function(func) {
  let isExcuted = false;
  let result;

  return function() {
  if ( !isExcuted ) {
    isExcuted = true;
    result = func.apply(null, arguments);
    return result;
    }
    else {
    return result;
    };
  };
};

const add = funcOnce(function(x, y, z) {
return x + y + z;
});

const multiply = funcOnce(function(x, y, z) {
return x * y * z;
});

add(1, 2, 3) // 6
multiply(2, 2, 2) // 8

add(3, 3, 3) // 6
mutiply(1, 1, 1) // 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;funcOnce는 Callback 함수를 한 번만 호출하는 함수이고, 이 함수가 반환한 함수는 자신이 만들어진 환경(Lexical Environment)를 기억하는 클로저입니다. 클로저는 변수 isExcuted와 result가 무엇인지 기억합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;add는 수를 더하는 함수입니다. 이 함수의 결과를 보면, 첫 실행 이후 다음 실행에는 반환값이 전달인자의 합이 아닌 것을 볼 수 있습니다. &lt;strong&gt;변수 isExcuted와 result가 클로저에 의해 참조되므로 유효한 상태이며, 최신상태를 계속 유지하기 때문입니다.&lt;/strong&gt; 다음 실행(add(3,3,3))에서 isExcuted = true, result = func.apply(null, [1, 2, 3])로 저장되어 있으므로 결과값은 6이 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변수 add와 multiply는 독립된 환경을 가지고 있습니다. 이는 multiply를 처음 실행했을 때 확인할 수 있습니다. add와 multiply 모두 isExcuted와 result를 가지고 있지만, 독립적으로 실행됩니다.  &lt;strong&gt;funcOnce를 호출하여 반환된 함수는 자신만의 독립된 환경을 가집니다. 변수 add와 multiply에 할당된 함수는 각각 자신만의 독립된 환경을 가지므로, 자유변수 isExcuted와 result를 공유하지 않습니다.&lt;/strong&gt; 함수형 프로그래밍에서는 이러한 특징을 이용하여 함수를 재사용하는데, 이를 커링(Currying)라 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-전역변수-사용-억제&quot;&gt;2.2 전역변수 사용 억제&lt;/h3&gt;
&lt;p&gt;위 스크립트를 실행하면 변수 add와 multiply에는 함수(function() {….})가 할당됩니다. 위에 언급했듯이, 이 함수는 자신이 생성된 환경(Lexical Environment)를 기억하는 클로저입니다. 커링 함수에서 funcOnce는 호출 직후 소멸되지만, 반환한 함수는 변수(add, multiply)에 할당되어, 커링함수를 호출할 때마다 내부에서 호출됩니다.&lt;/p&gt;

&lt;p&gt;add, multiply에서 funcOnce는 각각 한 번만 실행되므로, 변수 isExcuted와 result를 다시 초기화하지 않습니다. 또한, 외부에서 직접 접근할 수 없는 지역변수이므로, 전역변수를 사용했을 때와 같이 의도치 않은 변경이 일어나지 않습니다. 전역변수를 만들지 않더라도 초기화되지 않으며 현재 상황을 계속 확인할 수 있는 자유변수를 만들 수 있습니다. 그리고, 자유변수는 전역 스코프에서 직접 접근할 수도 없습니다.&lt;/p&gt;

&lt;h2 id=&quot;3-reference&quot;&gt;3. Reference&lt;/h2&gt;
&lt;p&gt;*https://poiemaweb.com/js-closure  &lt;br /&gt;
*https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures&lt;/p&gt;</content><author><name>liondoge</name></author><category term="Javascript101" /><summary type="html">클로져의 정의와 활용</summary></entry><entry><title type="html">복잡도(Complexity)</title><link href="https://kavoom2.github.io/javascript101/complexity/" rel="alternate" type="text/html" title="복잡도(Complexity)" /><published>2021-01-01T00:00:00+09:00</published><updated>2021-01-05T06:20:00+09:00</updated><id>https://kavoom2.github.io/javascript101/complexity</id><content type="html" xml:base="https://kavoom2.github.io/javascript101/complexity/">&lt;p&gt;(수정 중인 TIL.)&lt;/p&gt;

&lt;h2 id=&quot;1-복잡도&quot;&gt;1. 복잡도&lt;/h2&gt;
&lt;p&gt;처리해야 할 데이터의 양이 방대해지면서, 알고리즘의 효율성 차이가 커질 수 밖에 없습니다. 가령, 데이터를 정렬하더라도 정렬 알고리즘마다 정렬에 걸리는 시간은 천차만별입니다. 방대한 데이터를 더 빨리 처리할 수 있는 방법을 선택해야겠습니다.&lt;/p&gt;

&lt;p&gt;서로 다른 알고리즘을 비교할 때, 하드웨어와 소프트웨어 환경이 천차만별이라면 결과를 신뢰하기 힘들겁니다. 계산복잡도는 이러한 환경을 배제하고 알고리즘이 얼마나 효율적인지 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;계산복잡도의 기준은 알고리즘이 소모하는 소요시간과 메모리 사용량 등 자원으로 구분합니다. 전자를 시간복잡도(Time complexity), 후자를 공간복잡도(Space complexity)라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;1-1-점근-표기법---빅오-표기법big-o-notation&quot;&gt;1. 1. 점근 표기법 - 빅오 표기법(Big-O notation)&lt;/h3&gt;
&lt;p&gt;점근표기법은 오메가 표기법, 세타 표기법, 빅오 표기법이 있습니다. 각각 최선, 평균, 최악의 경우 복잡도를 나타냅니다. 어떤 환경에서 사용할 알고리즘인지에 따라 다르겠지만, 보통 빅오 표기법으로 복잡도를 판단합니다.&lt;/p&gt;

&lt;p&gt;빅오 표기법은 시공간 복잡도를 수학적으로 표기하는 대표적인 방법입니다. 알고리즘의 성능을 논리적으로 예측하기 위해 사용합니다. 빅오 표기법에는 다음과 같은 두 가지 규칙이 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;영향력이 가장 큰 최고차항 이외의 항들은 무시합니다.
    &lt;ul&gt;
      &lt;li&gt;$f(n)=n^2 + n$ —-&amp;gt; $O(n^2)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최고차항의 계수와 상수항은 무시합니다.
    &lt;ul&gt;
      &lt;li&gt;$f(n)=3n + 10$ —-&amp;gt; $O(n)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$3n +10$의 복잡도를 가진다고 하지 않는 이유는 정확한 단계 수를 결정하기가 어렵기 때문입니다. 정확한 단계를 알고자 들여야하는 비용이 낭비를 초래할 수 있습니다. 그보다는 ‘이 알고리즘은 $n$에 비례한다.’라는 정보만으로 충분히 성능을 가늠할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/2928/1*5ZLci3SuR0zM_QlZOADv8Q.jpeg&quot; alt=&quot;Understanding time complexity with Python examples | by Kelvin Salton do  Prado | Towards Data Science&quot; /&gt;
한편, 대부분의 알고리즘은 아래와 같은 수식으로 나타낼 수 있습니다.  위로 갈 수록 간단하고, 아래로 갈 수록 복잡해집니다. ($log_2n$은 $logn$을 의미합니다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$O(1)$과 같은 상수 형태 (정수가 짝수이거나 홀수인지 판단)   &lt;br /&gt;
$O(logn)$과 같은 로그 형태 (이진탐색 - 자료의 수가 $2^n$이면, 복잡도는 $log_2(2^n) = n$)  &lt;br /&gt;
$O(n)$과 같은 선형 형태 (정렬되지 않은 배열에서 최솟값이나 최댓값 탐색) &lt;br /&gt;
$O(nlogn)$과 같은 선형로그 형태 (퀵 정렬, 병합정렬, 힙 정렬 등)  &lt;br /&gt;
$O(n^c)$과 같은 다차 형태 (이중반복문이나 버블 정렬, 선택 정렬, 삽입 정렬 등)  &lt;br /&gt;
$O(c^n)$과 같은 지수 형태  &lt;br /&gt;
$O(n!)$과 같은 팩토리얼 형태&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1-2-공간복잡도space-complexity&quot;&gt;1. 2. 공간복잡도(Space complexity)&lt;/h3&gt;
&lt;p&gt;공간복잡도는 어떤 프로그램을 실행시킨 후 완료하기까지 필요로 하는 자원공간의 양입니다. 메모리 공간을 얼마나 효율적으로 사용하는지 나타내는 개념인 것이죠. 총요구공간 $S(P)$은 고정요구공간 $c$와 가변요구공간 $S_p(n)$의 합으로 나타낼 수 있습니다.&lt;/p&gt;

&lt;center&gt; $S(P) = c + S_p(n)$&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
고정공간은 입출력의 횟수와 크기에 관계없는 요구공간을 말합니다. 코드 저장공간, 단순변수, 고정크기의 구조변수, 상수가 해당된다고 합니다. 가변공간은 해결하려는 문제의 특정 인스턴스에 따라 가변적인 크기를 가진 구조화 변수들을 필요로 하는 공간, 함수가 순환호출을 할 경우 요구되는 추가공간을 말합니다.&lt;/p&gt;

&lt;p&gt;$n!$을 계산하는 함수를 반복문과 재귀함수로 작성하여 비교해봅시다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 재귀함수
function factorialByRecursion(n) {
  if ( n === 1 ) {
    return 1;
  };
  return factorial(n - 1);
};

//반복문으로 작성한 함수
function factorialByLoop(n) {
  let result = 1;
  for ( let i = 0; i &amp;lt;= n; i++ ) {
    result = result * i;
  };
  return result;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;재귀함수로 작성한 함수는 n === 1이 될 때 까지 서브함수를 호출합니다. 따라서 스택에는 실행 컨텍스트가 n에서 1까지 쌓이게 됩니다. 공간복잡도는 $O(n)$이 됩니다. 반복문으로 구현한 함수는 n의 값에 상관없이 실행 컨텍스트는 하나만 존재합니다. 공간복잡도가 $O(1)$인 것이죠.&lt;/p&gt;

&lt;h3 id=&quot;1-3-시간복잡도time-complexity&quot;&gt;1. 3. 시간복잡도(Time complexity)&lt;/h3&gt;
&lt;p&gt;시간복잡도는 알고리즘을 수행하는 데 얼마나 많은 연산이 수행되어야 하는지 숫자로 표기합니다. 하드웨어, 프로그래밍 언어 등 환경에 따라 편차가 크기 때문에 명령어의 실행 횟수만으로 판단합니다.&lt;/p&gt;

&lt;p&gt;유사한 기능을 수행하는 알고리즘 간의 성능차이를 확연히 느끼고 싶다면, 정렬 알고리즘을 확인해봅시다.&lt;/p&gt;

&lt;h2 id=&quot;2-더-알아보기---정렬-알고리즘sorting-algorithm&quot;&gt;2. 더 알아보기 - 정렬 알고리즘(Sorting algorithm)&lt;/h2&gt;
&lt;p&gt;처음으로 정렬 알고리즘을 구현할 때 중첩반복문으로 구현했습니다. n개의 자료를 정렬한다면 시간반복도는 $O(n^2)$이 되겠죠. 테스트 케이스 규모가 작아서 느끼지 못했지만, 수십, 수백만 개 자료를 정렬한다면 굉장히 비효율적일겁니다.&lt;/p&gt;

&lt;p&gt;다음 예제들을 보면서 어떤 정렬 알고리즘이 있고, 어떻게 작동되는지 알아봅시다.&lt;/p&gt;

&lt;h2 id=&quot;2-1-시간반복도-on2-정렬&quot;&gt;2. 1. 시간반복도 $O(n^2)$ 정렬&lt;/h2&gt;

&lt;h3 id=&quot;2-1-1-버블-정렬bubble-sort&quot;&gt;2. 1. 1. 버블 정렬(Bubble Sort)&lt;/h3&gt;
&lt;p&gt;1번째와 2번째 원소를 비교하여 정렬하고, 2번째와 3번째, …, n-1번째와 n번째를 확인하여 정렬한 뒤 다시 처음으로 돌아가 n-2번째와 n-1번째까지, …를 반복하는 정렬입니다. 매 순회마다 마지막 하나가 정렬되어 원소들이 거품처럼 올라오는 것처럼 보입니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function bubbleSort(arr) {
  let length = arr.length - 1;
  let temp;
  for ( let i = 0; i &amp;lt; length; i++ ) {
    for ( let j = 0; j &amp;lt; length - 1 - i; j++ ) {
      if (arr[j] &amp;gt; arr[j + 1]) {
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      };
    };
  };
  return arr;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-1-2-칵테일-정렬cocktail-shaker-sort&quot;&gt;2. 1. 2. 칵테일 정렬(Cocktail shaker sort)&lt;/h3&gt;
&lt;p&gt;홀수 번째 요소는 앞에서부터 확인하고, 짝수 번째 요소는 뒤에서부터 확인합니다. 버블 정렬이 마지막에서 처음으로 정렬했다면, 칵테일 정렬은 처음과 마지막을 번갈아가면서 정렬합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function shakerSort(arr) {
  const length = arr.length - 1;
  let isSorted = false;
  
  while (!isSorted) {
    isSorted = true;
    for ( let i = 0; i &amp;lt; length; i++ ) {
      if (arr[i] &amp;gt; arr[i + 1]) {
        let temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
        isSorted = false;
      };
    };
    
    if (isSorted) {
      break;
    };
    isSorted = true;

    for ( let j = length - 1; j &amp;gt;0; j-- ) {
      if ( arr[j - 1] &amp;gt; arr[j] ) {
        let temp = arr[j];
        arr[j] = arr[j-1];
        arr[j-1] = temp;
        isSorted = false;
      };
    };
  };
  return arr;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-1-3-선택-정렬selection-sort&quot;&gt;2. 1. 3. 선택 정렬(Selection sort)&lt;/h3&gt;
&lt;p&gt;버블정렬이 매번 두 요소를 비교하여 위치를 바꾼다면, 선택 정렬은 처음부터 마지막까지 한 번 훑어 정렬하고, 그 다음은 2번째에서 마지막까지 순환하는 방식으로 정렬합니다. 정렬이 일관성있게 $n(n-1)/2$에 비례하는 시간이 걸립니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function selectionSort(arr) {
  for ( let i = 0; i &amp;lt; arr.length - 1; i++ ) {
    let minimumNumIdx = i;
    for ( let j = i + 1; j &amp;lt; arr.length; j++ ) {
      if ( arr[minimumNumIdx] &amp;gt; arr[j] ) {
        minimumNumIdx = j;
      };
    };
    if ( minimumNumIdx !== i ) {
      let temp = arr[minimumNumIdx];
      arr[minimumNumIdx] = arr[i];
      arr[i] = temp;
    };
  };
  return arr;
}; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-1-4-삽입-정렬insertion-sort&quot;&gt;2. 1. 4. 삽입 정렬(Insertion sort)&lt;/h3&gt;
&lt;p&gt;$n$번째 원소를 첫 번째에서 $n-1$번째까지 비교하여 적절한 위치에 놓고, 그 뒤의 자료들을 한 칸씩 밀어내는 정렬방식입니다.  $O(n^2)$ 중 빠른 편이지만, 오름차순 정렬일 때 작은 요소들이 뒤 쪽에 몰려있으면 많은 시간이 걸립니다.&lt;/p&gt;

&lt;p&gt;다만, 자료구조가 이미 정렬되어있거나 규모가 작다면 굉장히 효과적인 알고리즘입니다. 고성능 알고리즘 중에서는 배열 규모가 클 때 $O(nlogn)$ 알고리즘을 사용하다가, 정렬해야 할 부분이 작으면 삽입정렬로 전환하기도 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function insertionSort(arr) {
  for ( let i = 1; i &amp;lt; arr.length; i++ ) {
    let currentEl = arr[i];
    let j = i-1;
    while ( (j &amp;gt; -1) &amp;amp;&amp;amp; (currentEl &amp;lt; arr[j]) ) {
      arr[j + 1] = arr[j];
      j--;
    };
    arr[j + 1] = currentEl;
  };
  return arr;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-2-시간반복도-onlogn-정렬&quot;&gt;2. 2. 시간반복도 $O(nlogn)$ 정렬&lt;/h2&gt;

&lt;h2 id=&quot;3-reference&quot;&gt;3. Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://velog.io/@raram2/big-o-notation-and-time-complexity&lt;/li&gt;
  &lt;li&gt;https://madplay.github.io/post/time-complexity-space-complexity&lt;/li&gt;
  &lt;li&gt;https://en.wikipedia.org/wiki/Time_complexity&lt;/li&gt;
  &lt;li&gt;https://d2.naver.com/helloworld/0315536 - 정렬 알고리즘의 시간복잡도, 꼭 읽어봅시다.&lt;/li&gt;
  &lt;li&gt;https://blog.chulgil.me/algorithm/&lt;/li&gt;
  &lt;li&gt;https://stackabuse.com/bubble-sort-and-cocktail-shaker-sort-in-javascript/&lt;/li&gt;
  &lt;li&gt;https://loving-wright-d0eedb.netlify.app/blog/selection-sort-in-javascript&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>liondoge</name></author><category term="Javascript101" /><summary type="html">공간복잡도와 시간복잡도 그리고 정렬 알고리즘</summary></entry><entry><title type="html">재귀(Recursion)</title><link href="https://kavoom2.github.io/javascript101/recursion/" rel="alternate" type="text/html" title="재귀(Recursion)" /><published>2021-01-01T00:00:00+09:00</published><updated>2021-01-05T06:15:00+09:00</updated><id>https://kavoom2.github.io/javascript101/recursion</id><content type="html" xml:base="https://kavoom2.github.io/javascript101/recursion/">&lt;h2 id=&quot;1-재귀란&quot;&gt;1. 재귀란?&lt;/h2&gt;
&lt;p&gt;컴퓨터 과학에서 재귀(recursion)은 자신을 정의할 때 자기 자신을 참조하는 것이라고 합니다. 프로그래밍에서 재귀함수는 자기 자신을 호출하도록 정의한 함수입니다.&lt;/p&gt;

&lt;h3 id=&quot;1-1-재귀함수의-구성요소&quot;&gt;1. 1. 재귀함수의 구성요소&lt;/h3&gt;
&lt;p&gt;재귀함수는 베이스(base case)와 재귀단계(recursive case)로 구성됩니다.
x를 n 제곱하는 함수 pow(x, n)을 예시로 재귀함수의 구성과 작동원리를 이해해봅시다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function pow(x, n) {
  if (n === 1) {
    return x; // Base case
  };

  return x * pow(x, n - 1); // Recursive case
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 함수는 다음 단계로 나누어져 실행됩니다.&lt;/p&gt;

&lt;div class=&quot;mermaid&quot;&gt;
graph LR
A[&quot;pow(x, n)&quot;] --&amp;gt; B{&quot;n === 1?&quot;}
B -- &quot;No&quot; --&amp;gt; C(&quot;x * pow(x, n-1)&quot;)
C -- &quot;recursive call until n === 1&quot; --&amp;gt; A
B -- &quot;Yes&quot; --&amp;gt; D(&quot;return x&quot;)
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;Base case( n=== 1 ): 즉시 x에 해당하는 값을 반환합니다.&lt;/p&gt;

  &lt;p&gt;Recursive case( n !== 1): pow(x, n) 은 x * pow(x, n-1)으로 표현할 수 있습니다. 즉, pow(x, n)은 pow(x, n-1)을 참조해야 하며, Base case에 도달할 때까지 서브함수를 참조하는 재귀단계를 반복합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서, pow(2, 4)를 실행하면 다음과 같은 4단계로 재귀함수를 호출합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;stage 1: pow(2, 4) = 2 * pow(2, 3)   &lt;br /&gt;
stage 2: pow(2, 3) = 2 * pow(2, 2)  &lt;br /&gt;
stage 3: pow(2, 2) = 2 * pow(2, 1)  &lt;br /&gt;
stage 4: pow(2, 1) = 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1-2-서브호출subcall과-실행-컨텍스트execution-context&quot;&gt;1. 2. 서브호출(subcall)과 실행 컨텍스트(Execution Context)&lt;/h3&gt;

&lt;p&gt;pow(2, 4)를 실행하면 순차적으로 pow(2, 3)에서 pow(2, 1)까지 생성됩니다. 실행 중인 함수의 정보는 함수의 실행 컨텍스트(Execution Context)에 저장됩니다. 함수 호출 1회마다 하나의 실행 컨텍스트가 실행됩니다. 예제에서는 총 4개의 컨텍스트가 생성됩니다.&lt;/p&gt;

&lt;div class=&quot;mermaid&quot;&gt;
graph TB
subgraph step 4
G[&quot;context: {x: 2, n: 1}&quot;] --- H[&quot;context {x: 2, n: 2}&quot;]
H --- I[&quot;context: {x: 2, n: 3}&quot;]
I --- J[&quot;context: {x: 2, n: 4}&quot;]
end

subgraph step 3
D[&quot;context: {x: 2, n: 2}&quot;] --- E[&quot;context: {x: 2, n: 3}&quot;]
E --- F[&quot;context: {x: 2, n: 4}&quot;]
end

subgraph step 2
B[&quot;context: {x: 2, n: 3}&quot;] --- C[&quot;context: {x: 2, n: 4}&quot;]
end

subgraph step 1
A[&quot;context: {x: 2, n: 4}&quot;]
end
&lt;/div&gt;

&lt;p&gt;첫 호출 pow(2, 4)를 계산하려면 새로운 서브 호출(subcall) pow(2, 3)을 만들어야 합니다. 새로 만들어진 실행 컨텍스트는 스택 최상단에 위치하게 됩니다. 이전 실행 컨텍스트인 pow(2, 4)는 중지된 상태로 남게됩니다. 동일한 과정을 pow(2, 1)까지 반복합니다.&lt;/p&gt;

&lt;center&gt;&lt;div class=&quot;mermaid&quot;&gt;
graph TB
subgraph step 5-8
A[&quot;context: {x: 2, n: 1}&quot;] --&quot;return 2, destroy current context&quot;--&amp;gt; B[&quot;context {x: 2, n: 2}&quot;]
B --&quot;return 4, destroy current context&quot;--&amp;gt; C[&quot;context: {x: 2, n: 3}&quot;]
C --&quot;return 8, destroy current context&quot;--&amp;gt; D[&quot;context: {x: 2, n: 4}&quot;]
D --&quot;return 16&quot;, destroy current context--&amp;gt; E(&quot;result = 16&quot;)
end
&lt;/div&gt;&lt;/center&gt;
&lt;p&gt;pow(2, 1)이 실행되면 상황이 달라집니다. base case(n === 1)을 만족하여 2가 반환됩니다. 서브호출 없이 함수가 종료되었죠. 함수가 종료되면 상응하는 실행컨텍스트는 메모리에서 폐기됩니다. 최상단 컨텍스트가 삭제되면, 바로 아래에 있는 컨텍스트가 최상단 컨텍스트가 되어 반환값을 받아 다시 실행됩니다. 이 과정을 실행 컨텍스트가 스택에 쌓일 때의 역순으로 반복하게 됩니다.&lt;/p&gt;

&lt;p&gt;실행 컨텍스트는 그 함수가 종료되어 폐기되기 전까지 메모리를 차지하게 됩니다. 따라서, 재귀함수를 사용할 땐 메모리 요구사항을 유의해야 합니다. 보통 위와 같은 단편적인 문제는 반복문 기반의 알고리즘을 사용하는 것이 효과적입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;함수를 호출할 때 함수의 입력값 (매개 변수: argument), 리턴값, 리턴됐을 때 돌아갈 위치값 등을 스택에 저장한다. 재귀함수를 사용하면 함수가 끝나지 않은 채 연속적으로 함수를 호출하므로 스택에 메모리가 쌓이게 된다. 이 때문에 스택의 최대 크기 이상의 메모리가 쌓이게 되면 스택 오버 플로우가 일어나게 된다. 잦은 점프의 반복으로 성능이 저하될 위험도 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1-3-꼬리-재귀tail-recursion&quot;&gt;1. 3. 꼬리 재귀(Tail recursion)&lt;/h3&gt;
&lt;p&gt;꼬리재귀는 재귀함수의 단점인 지나친 메모리 점유율을 해결하기 위한 호출방식 중 하나입니다. 재귀함수의 실행결과가 연산에 사용되지 않고 바로 반환되도록 하여 이전 함수의 상태를 유지할 필요가 없도록 함수를 작성하는 것입니다. 꼬리 재귀가 정상적으로 동작하려면 플랫폼에서 TGO(Tail Call Optimization)을 지원해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 일반 재귀함수
function factorial(n) {
  if (n === 1) {
    return 1;
  };
  return n * factorial(n - 1);
};

// 꼬리 재귀함수
function factorial(n) {
  function factorialTail(n, acc) {
    if (n === 1) {
      return acc;
    };
    return factorialTail(n - 1, acc * n);
  };
  return factorialTail(n, 1);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;꼬리재귀 함수는 acc(accumulator)라는 인자를 하나 더 가지고 있습니다. 보이지는 않지만, 컴파일러가 꼬리재귀 함수를 반복문으로 바꾸어줍니다. 실제 동작 또한 스택을 한 번만 호출하게 됩니다.&lt;/p&gt;

&lt;p&gt;자세한 내용은 레퍼런스 중 꼬리재귀 함수 관련 내용을 참조할 것.&lt;/p&gt;

&lt;h2 id=&quot;2-reference&quot;&gt;2. Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://ko.javascript.info/recursion&lt;/li&gt;
  &lt;li&gt;https://bozeury.tistory.com/entry/꼬리-재귀-최적화Tail-Recursion&lt;/li&gt;
&lt;/ul&gt;</content><author><name>liondoge</name></author><category term="Javascript101" /><summary type="html">재귀함수의 구성요소와 작동방식</summary></entry><entry><title type="html">This</title><link href="https://kavoom2.github.io/javascript101/this/" rel="alternate" type="text/html" title="This" /><published>2021-01-01T00:00:00+09:00</published><updated>2021-01-05T06:10:00+09:00</updated><id>https://kavoom2.github.io/javascript101/this</id><content type="html" xml:base="https://kavoom2.github.io/javascript101/this/">&lt;h2 id=&quot;1-this란&quot;&gt;1. this란&lt;/h2&gt;
&lt;p&gt;this는 모든 함수 스코프(scope) 내에서 자동으로 설정되는 식별자입니다. 실행 컨텍스트(Execution Context)의 구성요소로 함수가 실행되는 동안 이용할 수 있습니다. &lt;strong&gt;어느 지점에서 this를 호출하였는지에 따라 컨텍스트가 달라집니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-바인딩-규칙&quot;&gt;2. 바인딩 규칙&lt;/h2&gt;
&lt;p&gt;규칙은 다음과 같이 5가지로 구분할 수 있습니다. 바인딩 우선순위는 명시적 바인딩 - 암시적 바인딩 - 기본 바인딩 순입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;구분&lt;/th&gt;
      &lt;th&gt;호출방식&lt;/th&gt;
      &lt;th&gt;this&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;기본 바인딩&lt;/td&gt;
      &lt;td&gt;global&lt;/td&gt;
      &lt;td&gt;window(전역객체)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;기본 바인딩&lt;/td&gt;
      &lt;td&gt;function 호출&lt;/td&gt;
      &lt;td&gt;window(전역객체)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;암시적 바인딩&lt;/td&gt;
      &lt;td&gt;method 호출&lt;/td&gt;
      &lt;td&gt;object(직계부모)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Constructior&lt;/td&gt;
      &lt;td&gt;method 호출&lt;/td&gt;
      &lt;td&gt;새로 생성한 object&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;명시적 바인딩&lt;/td&gt;
      &lt;td&gt;apply(), call(), bind()&lt;/td&gt;
      &lt;td&gt;첫 번째 인자로 명시한 객체&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;2-1-기본-바인딩global-function&quot;&gt;2. 1. 기본 바인딩(global, function)&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo() {
  console.log(this.hello);
};

function bar() {
  'use strict'
  console.log(this.hello);
};

var hello = 'world'; // var로 정의한 변수만 window에 속한다.
foo(); // 'world'
bar(); // SyntaxError: Cannot read property 'hello' of undefined at bar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;foo() 함수를 실행하면 this는 전역객체(window)에 바인딩 됩니다. 자바스크립트에서 global, function 호출은 전역객체에 바인딩하는 것이 기본규칙입니다. 엄격모드(‘use strict’)를 사용하면 this는 전역객체가 아닌 undefined가 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;2-2-암시적-바인딩implicit-binding&quot;&gt;2. 2. 암시적 바인딩(implicit binding)&lt;/h3&gt;
&lt;p&gt;암시적 바인딩은 함수 호출 시 객체의 프로퍼티에 접근하는 방식입니다. this는 호출한 method의 직계부모 object로 바인딩됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let obj = {
  fn: function(a, b) {
    return this;
  }
};

let obj2 = {
  method: obj.fn
};

let objFn = obj.fn;

console.log(obj2.method()); // obj2
console.log(obj.fn()); // obj
objFn() // window
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예제에서 객체 obj에 속성 fn의 값으로 함수를 할당했습니다. 그리고 이 객체를 통해서 fn()을 호출하였죠. 함수를 개체 프로퍼티를 통하여 접근하여 실행하면, 이 객체를 this에 바인딩하게 됩니다. 이를 암시적 바인딩이라고 합니다.&lt;/p&gt;

&lt;p&gt;한편, 객체 obj2의 속성에 함수 obj.fn을 할당하였습니다. obj2.method()의 값은 obj.fn()을 실행한 것이니 obj라고 생각할 수 있습니다. 하지만, &lt;strong&gt;암시적 바인딩은 어느 지점에서 함수를 호출하였는지에 따라 this의 context가 달라집니다.&lt;/strong&gt;  obj2.method = obj.fn이지만, obj2.method의 직계부모는 obj2입니다. 규칙에 따라 this는 obj2로 바인딩됩니다.&lt;/p&gt;

&lt;p&gt;마지막으로 objFn은 객체 속성으로 함수를 호출한 것이 아닙니다. 변수 objFn에 함수를 할당하여 실행했으므로 window객체가 바인딩됩니다.&lt;/p&gt;

&lt;h3 id=&quot;2-3-명시적-바인딩explicit-binding&quot;&gt;2. 3. 명시적 바인딩(Explicit binding)&lt;/h3&gt;
&lt;p&gt;암시적 바인딩은 위 예제에 알 수 있듯이, 어떤 객체에 바인딩 될지 직관적이지 않습니다. 자바스크립트의 call(), apply(), bind() 함수는 어떤 객체를 컨텍스트로 정할 것인지 명시할 수 있는 내장함수입니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function foo() {
  console.log(this.hello);
};

var obj = {
  hello: 'world',
};

var hello = 'this is a global context'

foo.call(obj) // 'world'

setTimeout(obj.hello.bind(obj), 1000) // 1000ms 뒤에 world 출력
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;call(), apply(), bind() 함수에 this 컨텍스트와 바인딩할 객체를 명시할 수 있습니다. 위 예제에서는 foo() 함수가 실행되면 this는 window 객체가 아닌 obj 객체가 됩니다.&lt;/p&gt;

&lt;p&gt;한편, setTimeout에 넘겨준 콜백함수에서 발생한 문제도 명시적 바인딩으로 해결할 수 있습니다. setTimeout에 콜백함수를 obj.hello로 넘기면, 글로벌 컨텍스트가 바인딩됩니다. obj.hello.bind(obj)는 hello()함수를 실행했을 때 obj를 this 컨텍스트로 바인딩하게 됩니다. 명시적 바인딩의 우선순위가 가장 높으니, 정상적으로 world가 출력됩니다.&lt;/p&gt;

&lt;h3 id=&quot;2-4-constructor&quot;&gt;2. 4. Constructor&lt;/h3&gt;
&lt;p&gt;자바스크립트 함수 앞에 new를 붙여 실행하면 다음과 같은 일이 일어납니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;새로운 객체를 반환합니다.&lt;/li&gt;
  &lt;li&gt;새로운 객체는 객체의 메소드 호출 시 this로 바인딩됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name) {
  this.name = name;
};

Person.prototype.hello() {
  console.log(this.name);
};

var obj = new Person('chris');
obj.hello(); // 'chris'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-reference&quot;&gt;3. Reference&lt;/h2&gt;
&lt;p&gt;*https://velog.io/@litien/Javascript-This-Binding  &lt;br /&gt;
*https://developer.mozilla.org - this / call() / apply() / bind()&lt;/p&gt;</content><author><name>liondoge</name></author><category term="Javascript101" /><summary type="html">내부 식별자 This의 맥락에 따른 바인딩 규칙</summary></entry></feed>